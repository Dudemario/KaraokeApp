"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var constants_1 = require("./constants");
var parse_1 = require("./parse");
var utils_1 = require("./utils");
/**
 * <00:00.000>
 * <00:00.00>
 * <00:00>
 */
var ENHANCED_TIME = /<\d{2,}:\d{2}(?:\.(?:\d{2,3}))?>/g;
function parseEnhanced(lrc) {
    var lines = (0, parse_1["default"])(lrc);
    return lines.map(function (line) {
        if (line.type === constants_1.LineType.LYRIC) {
            var words = [];
            var wordTimeTagMatch = line.content.match(ENHANCED_TIME);
            if (!wordTimeTagMatch) {
                /**
                 * no time tag but having content is invalid
                 * like [time] xxxxx
                 * @author mebtte<hi@mebtte.com>
                 */
                if (line.content.trim().length) {
                    return {
                        type: constants_1.LineType.INVALID,
                        lineNumber: line.lineNumber,
                        raw: line.raw
                    };
                }
            }
            else {
                var wordContents = line.content.split(ENHANCED_TIME);
                /**
                 * ignore first emptiness or only-space
                 * @author mebtte<hi@mebtte.com>
                 */
                if (wordContents[0].trim().length === 0) {
                    wordContents.shift();
                }
                /**
                 * time tag' length should equal to content's length
                 * @author mebtte<hi@mebtte.com>
                 */
                if (wordTimeTagMatch.length !== wordContents.length) {
                    return {
                        type: constants_1.LineType.INVALID,
                        lineNumber: line.lineNumber,
                        raw: line.raw
                    };
                }
                for (var i = 0; i < wordTimeTagMatch.length; i += 1) {
                    var timestamp = wordTimeTagMatch[i];
                    var content = wordContents[i];
                    words.push({
                        index: i,
                        raw: "".concat(timestamp).concat(content),
                        startMillisecond: (0, utils_1.timestampToMillsecond)(timestamp.replace(/[<>]/g, '')),
                        content: content
                    });
                }
            }
            return __assign(__assign({}, line), { type: constants_1.LineType.ENHANCED_LYRIC, words: words });
        }
        return line;
    });
}
exports["default"] = parseEnhanced;
